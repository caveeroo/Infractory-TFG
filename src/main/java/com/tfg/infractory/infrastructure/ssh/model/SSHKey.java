package com.tfg.infractory.infrastructure.ssh.model;

import jakarta.persistence.*;
import lombok.Data;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;

@Entity
@Data
public class SSHKey {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @Column(columnDefinition = "TEXT")
    private String publicKey;

    // Name of the secret holding the encrypted private key
    @Column(unique = true, nullable = true) // nullable=true if some keys might not have private parts stored
    private String privateKeySecretName;

    @Column(unique = true)
    private String fingerprint;

    @PrePersist
    @PreUpdate
    private void generateFingerprint() {
        if (publicKey != null && (fingerprint == null || fingerprint.isEmpty())) {
            try {
                String[] parts = publicKey.split("\\s+");
                if (parts.length >= 2) {
                    byte[] keyBytes = Base64.getDecoder().decode(parts[1]);
                    MessageDigest md = MessageDigest.getInstance("MD5");
                    byte[] digest = md.digest(keyBytes);
                    fingerprint = bytesToHex(digest);
                }
            } catch (NoSuchAlgorithmException | IllegalArgumentException e) {
                // Consider logging the error instead of throwing RuntimeException if
                // fingerprint generation is not critical
                System.err.println("Failed to generate SSH key fingerprint for key '" + name + "': " + e.getMessage());
                // Optionally set fingerprint to a default value or leave null
                // throw new RuntimeException("Failed to generate SSH key fingerprint", e);
            }
        }
    }

    private static String bytesToHex(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (byte b : bytes) {
            sb.append(String.format("%02x:", b & 0xff));
        }
        // Avoid potential index out of bounds if bytes is empty
        return sb.length() > 0 ? sb.substring(0, sb.length() - 1) : "";
    }

    // No direct getter/setter for the raw private key anymore

    // Getter for publicKey remains the same
    public String getPublicKey() {
        return publicKey;
    }

    // Standard getters/setters for other fields will be generated by Lombok @Data
}